
Linux Tutorial
* Linux Cmd 
** Linux File System
#+BEGIN_SRC 
(/)root
├── bin           #  
├── boot          # boot prg are present 
├── cdrom
├── core
├── dev           # devices: in linux: Has file system  "EVERY THING IS A FILE "
|                 # CONSsist of hardware, partions(sda,sda1,...,nvdia,web-cam)
|
├── etc           # all configuration files (/etc/passwd)
|
├── home          # (like c: drive os-users) cd ~ or cd <Enter>   
|
├── initrd.img
├── initrd.img.old
|
├── lib           # libray which are used to perform varies function
├── lib32
├── lib64
|
├── lost+found
|
├── media         # mount and media 
├── mnt
|
├── opt           # optional folder:  user space for exectue or store
├── proc          # sudo file : information of sys process and resources
├── root
├── run           # temp fs : Used for process which is boot early
├── sbin          # sys binary and standard users are not acess
├── snap          # snap packages are stored
├── srv           # service directory: If you run servers  the file are stored  
├── swapfile
├── sys           # way to interact with kernel
├── timeshift
├── tmp           # temparay folder 
├── usr           # user app space 
├── var           # all logs files are 
└── vmlinuz

#+END_SRC
** Linux BASIC cmd
#+BEGIN_SRC sh
  #############################################################
  #   Root User 
  # ##########################################################
  sudo su - # root user  # what is password for sudo su - ? 
  # How to know root user and normal user 
  # root user as       [root@ip-172-31-30-43 ~]#
  # normal user as [ec2-user@ip-172-31-30-43 ~]$

  # root user start with #(ash symbal) 
  # normal user start with $(doller symbol)
 
  sudo -i   # (alternative of root user)
  whoami
  # ##########################################################
  # Change directory
  # ##########################################################
  cd ..        # parent directory
  cd           # home directory
  cd ~         # home directory
  cd /         # root direcoty
  cd /opt      # 
  cd ~/.bashrc # in home dir .bashrc file

  # direct path or home path
  cd ~/Workspace/
  cd /home/jayaradhe/Workspace/


  # ##########################################################
  # print working directory
  # ##########################################################
  pwd 



  # ###########################################################
  # list directory
  # # ##########################################################
  ls
  ls -a                # all hidden files and dir
  ls -l                # long list format 
  ls dir/sub_dir_1/sub_dir_2
  ls -latr             # reverse 
  # How do you know the file in list is dir in (ls - l)
  # in < ls-l > cmd as d --- --- --- then it is directory


  ## ##########################################################
  #   Directory 
  ## ##########################################################
  mkdir SubDir1      # Create a Dir
  rm -R SubDir1      # Delete folder(dir) and inside files RECURSIVELY
  mv /path/SubDir1 /path/ # move directies
  cp -r /path/subdir1 /path/copied_subdir1   # copy directory
  rm -rf subdir1

  #
  # help
  # 
  man ls

  type echo # inbuilt or nor  with address



  ## ##########################################################
  # File Creation, Delete,copy,move,rename manupulation cmd
  ## ##########################################################


  touch test_file.txt              # create a file 
  mkdir test_files                 # create a directory
  cp test_file.txt copy_file.txt   # copy(or) duplicate a file
  mv test_file.tzt rename_file.txt # rename a file
  mv orig_file.txt SubDir1/        # move  to SubDir1 
  mv orig_file.txt SubDir1/rename_file.txt # move and remane 
  rm orig_file.txt   # Delete a file
  rm -R SubDir1      # Delete folder(dir) and inside files RECURSIVELY
  rm -rf subdir1
  ## ##########################################################
  #Other file commands 
  ## ##########################################################
  cat orig_file.txt  # print content of file in terminal
  vi orig_file.txt   # edit file
  nano orig_file.txt
  gedit orig_file.txt
  head -n1 /etc/passwd
  tail -n1 /etc/passwd
  less /etc/passwd

  # SEARCH "TEXT" in file 


  # grep : search text
  # grep "<text-need-2-search>" <filename>
  grep "at" sat

  #replace text 
  # sed -i 's/oldname/newname/g' <filename>
  # s (substitue) oldname / newname/g(global) in <filename>
  sed -i 's/todya/wednesday/g' sat
  less sat #  displays file contents or command output one page at a time in your terminal. 
           # less is most useful for viewing the content of large files 
 
  ## ##########################################################
  # Find files 
  # # ##########################################################

  find <path> -type f -name <name> # For find file
  find <path> -type d -name <name> # For find dir

  # Examples 
  touch phani kar sanjay sathish
  find /devops -type f -name kar # search "kar" file
  find /devops -type f -name "*.txt"
  mkdir india pakistan austriala asia china japan
  find /devops -type d -name asia               # search asia

  find . -type -d asia # '.' search in current dir(.)




  ## ##########################################################
  ##                   zip and un-zip         
  ## ########################################################## 

  tar -cvzf india.tar india            # c : craete v: verboz, z: zip   f:file
  tar -xvzf india.tar                  # x: extrach 


  ## ##########################################################
  # File permissions:
  ## ##########################################################

  # Change mode (permissions)

  drwx-rwx-rwx
  owner-group-user
  d: driectory 
  x(1) : user
  w(2) : write
  r(4) : read 

  0: --- 
  1: --x
  2: -w-
  3: -wx
  4: r--
  5: r-x
  6: rw-
  7: rwx

chmod 777 sat          # drwx rwx rwx   file
chmod -R 777 phani     # dir and inside files
chmod +x <file_name>  
chmod 755 sat         # drwx r-x r-x 
chmod 400 aws_key.pem # -r-- --- --- 

-rwx  rwx   rwx        1 root  root  1156 Mar 24 08:36 hosts
-rw   -r--  r--        1 root  root     0 Mar 24 14:17 ansible.txt
owner-group-user        owner  group
################################################################
[root@ansible-master ansible]# chown -R ansible:ansible ansible.txt 

-rwxrwxrwx  1 root    root     1156 Mar 24 08:36 hosts
-rw-r--r--  1 ansible ansible     0 Mar 24 14:17 ansible.tx


  ## ##########################################################
  # change owner of file or dir : chown
  ## ##########################################################
chown owner-user file 
chown owner-user:owner-group file/directory


# ls -l demo.txt      #>> -rw-r--r-- 1 root root 0 Aug 31 05:48 demo.txt

# chown vivek demo.txt 
# ls -l demo.txt      # >> -rw-r--r-- 1 vivek root 0 Aug 31 05:48 demo.txt

# chown vivek:vivek demo.txt
# ls -l demo.txt      #>>   -rw-r--r-- 1 vivek vivek 0 Aug 31 05:48 demo.txt


chown ec2-user:ec2-user <file/dir>

  # Eg:
  cd ~
  mkdir devops
  ls -latr
  chown -R ec2-user:ec2-user devops
  ls -latr 



  ## ##########################################################
  #    SSH
  ## ##########################################################

  # connect one linux to other linux
  ssh <other-user-name>@ip
  # passwd enter

  # copy for other user to current user
  scp <file-name> username@ip: /opt
  scp -i key.pem /path/to/myfile.txt ec2-user@IPAddressOfEC2:/ 

  ## ##########################################################
  #  Create Users
  ## ##########################################################

  user <new-user-name>   # create users
  passwd <new-user-name> # set password
  passwd <user-name>     # change password

  #eg :
  useradd phani
  passwd phani
  # Enter password


  cat  /etc/passwd       # to see password


  # histor
  ls -latr | grep test.sh | rm -rf
# disk size or disk free
  df - h # 

  ## ##########################################################
  # system moitor 
  ## ########################################################## 
  top # user id, user, cup, mem, swap, process name , process id # Ctrl-C
  #
  # diskspace or disk free (used available, % used) 
  #
  df -h # Or

#Filesystem      Size  Used Avail Use% Mounted on
#udev            3.8G     0  3.8G   0% /dev
#tmpfs           776M  1.6M  775M   1% /run
#/dev/sda1       916G  550G  320G  64% /
#tmpfs           3.8G  212M  3.6G   6% /dev/shm
#tmpfs           5.0M  4.0K  5.0M   1% /run/lock
#tmpfs           3.8G     0  3.8G   0% /sys/fs/cgroup
#/dev/loop0      185M  185M     0 100% /snap/eclipse/40
#/dev/loop1       63M   63M     0 100% /snap/gtk-common-t

  df -aPh # -a :all, P: Portable, h: human read able

  # directory size:  du -sh <dir_name> 
  # disk  usage : 
  du -sh asia  # -s : summarize , # -h : human readable
  du -sh sat
  du -sh * # size in current directory
  du -sh *.jpg # size of all jpg formate
# du -h Gitabase
# 378M	Gitabase

  # RAm size
  free -m


## ##########################################################
# process running 
## ##########################################################
ps -ef | grep <process-name>
ps -ef| grep tomcat
# UID        PID  PPID  C STIME TTY          TIME CMD
# jayradhe 23909  7504  0 13:38 pts/0    00:00:00 grep --color=auto tomcat

# UID: USER iD
# PID : Process Id
# PPID: Parent Process Id
# $ kill -kill <PID>  # to kill process
# $ kill -term <PID>  # to kill process

# $ kill -l 

# 1) SIGHUP	        2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
# 6) SIGABRT	7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
#11) SIGSEGV  	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
#16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
#21) SIGTTIN  	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
#26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
#31) SIGSYS  	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
#38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
#43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
#48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
#53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
#58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
#63) SIGRTMAX-1	64) SIGRTMAX	

kill -9 23909 

kill -9

  ## ##########################################################
  #         Network Cmd
  ## ########################################################## 
  ping google.com          # ping ip/dns/
  nslookup google.com      # for querying the Domain Name System to obtain domain name or IP address mapping, or other DNS records.
  telnet google.com 23     # check port 
  ifconfig
  netstat                  # (network statistics) displays network connections: Ip,port PID 
                           #  # Proto,  Recv-Q, Send-Q, Local Address(Port)           Foreign Address         State       PID/Program name
  # GET ip
ping google.com
#PING google.com (172.217.163.46) 56(84) bytes of data.
# 64 bytes from maa05s01-in-f14.1e100.net (172.217.163.46): icmp_seq=1 ttl=55 time=16.5 ms
# 64 bytes from maa05s01-in-f14.1e100.net (172.217.163.46): icmp_seq=2 ttl=55 time=17.1 ms
# 64 bytes from maa05s01-in-f14.1e100.net (172.217.163.46): icmp_seq=3 ttl=55 time=20.2 ms
# 64 bytes from maa05s01-in-f14.1e100.net (172.217.163.46): icmp_seq=4 ttl=55 time=88.2 ms
 
nslookup google.com      # for querying the Domain Name System to obtain domain name or IP address mapping, or other DNS records.

# Server:		127.0.0.53
# Address:	127.0.0.53#53

# Non-authoritative answer:
# Name:	google.com
# Address: 172.217.163.46
# Name:	google.com
# Address: 2404:6800:4007:80b::200e


  # check ports is running
netstat -anp | grep <ports-no> # all  p: PID , n: doesnot resolve name
# Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
# tcp        0      0 0.0.0.0:8888            0.0.0.0:*               LISTEN      -                   
# tcp        0      0 192.168.0.105:37756     52.40.23.85:443         ESTABLISHED 11770/firefox       
# tcp        0     32 192.168.0.105:52374     34.195.246.183:443      LAST_ACK    -                   

# Active UNIX domain sockets (servers and established)
# Proto RefCnt Flags       Type       State         I-Node   PID/Program name     Path
# unix  2      [ ACC ]     STREAM     LISTENING     34772    2332/systemd         /run/user/1000/systemd/private
# unix  2      [ ACC ]     STREAM     LISTENING     31708    -                    /run/user/123/systemd/private
# unix  2      [ ACC ]     STREAM     LISTENING     34776    2332/systemd         /run/user/1000/snapd-session-agent.socket
# unix  2      [ ACC ]     STREAM     LISTENING     31712    -                    /run/user/123/gnupg/S.dirmngr
# unix  3      [ ]         STREAM     CONNECTED     3237440  11770/firefox        
# unix  3      [ ]         STREAM     CONNECTED     3233405  7229/firefox         
# unix  3      [ ]         STREAM     CONNECTED     2101124  3731/vlc             
# unix  3      [ ]         STREAM     CONNECTED     830211   2389/dbus-daemon     /run/user/1000/bus
# unix  3      [ ]         STREAM     CONNECTED     38761    2712/blueberry-obex  
# unix  3      [ ]         STREAM     CONNECTED     38294    -                    /var/run/dbus/system_bus_socket
# unix  3      [ ]         STREAM     CONNECTED     37112    -                    /var/run/dbus/system_bus_socket
# unix  3      [ ]         STREAM     CONNECTED     31184    -                    /var/run/dbus/system_bus_socket
# unix  3      [ ]         STREAM     CONNECTED     37567    2813/cinnamon-scree  
# unix  3      [ ]         STREAM     CONNECTED     24609    -                    
# unix  3      [ ]         STREAM     CONNECTED     2099806  3731/vlc             
# unix  3      [ ]         STREAM     CONNECTED     37262    2489/csd-color       
# unix  3      [ ]         STREAM     CONNECTED     23321    -                    /var/run/dbus/system_bus_socket
# unix  3      [ ]         STREAM     CONNECTED     2529413  11770/firefox        
# unix  3      [ ]         STREAM     CONNECTED     2022448  11770/firefox        
# unix  3      [ ]         STREAM     CONNECTED     833750   3244/gvfsd-trash     @/dbus-vfs-daemon/socket-6kJqXg56
# unix  3      [ ]         STREAM     CONNECTED     38987    -                    /var/run/dbus/system_bus_socket

uptime  # find out how long system is active.
#Display the time since the last boot

#  
#   Run levels https://www.liquidweb.com/kb/linux-runlevels-explained/
#
Run levels 
#Q) What is runlevels in linux


# 
#  awk: cut columwise:
#
# syntax : awk '{print $3}' filename
df -h |grep /dev/xvda1 

# Example 
touch users
vi users
## insert below text
# sno     course   name  fee
# 1      devops   phani 15
# 2      devops   kar  15
# 3      devops   san 15
awk '{print $3}' sat

# Example : find size of /dev/xvda1
df -h |grep /dev/xvda1 | awk '{print $1, $4}'

#
#   Cut CHARACER Columwise : cut -c
#
cut -c 1 filename      # f
cut -c 1-5 filename    # filename
cut -c 1,6 filename    # fa
cut -c 1 sat 


#+END_SRC
** TODO Crontab
For Crontab : Example visit https://crontab.guru/examples.html
#+BEGIN_SRC sh

#
#    Crontab  
# 
# *  *  *   *   * 
# mm hh dd mon wek
# 1 * - minutes(0-59)
# 2 * - hours(0-23)
# 3 * - days(1-31)
# 4 * - months(1-12)
# 5 * - weeks(1-7)

# https://www.geeksforgeeks.org/crontab-in-linux-with-examples/

# Every 6.30am check diskspace  
30 6 * * *  df - h
#execute the Full backup shell script (full-backup) on 10th June 08:30 AM.
30 08 10 06 * /home/maverick/full-backup

# 1,2,3,5,8,13,21,34 * * * * df - h 
# Crontab will run Every Hour at 
# xx:01:00 (hh:mm:ss)
# xx:02:00
# xx:03:00
# xx:05:00
# xx:08:00
# xx:13:00
# xx:21:00
# xx:34:00


# Crontab for every 15 mints
0,15,30,45 * * * * dh -h
#or
*/15 * * * * df - h

# Every 2 hours
0 */2 * * * 

# Every 3 hours
0 */3 * * * 

crontab -e # edit cron tabs
crontab -l # list
crontab -r # delete 

#  *	        any value
#  ,	        value list separator
0,15,30,45 * * * * dh -h

#  /         	  step values
0 */2 * * * # every 2 hours
0 */3 * * * # every 3 hours  

#  -	        range of values
Say I have a crontab which runs every 20 minutes and I have a hour range which can vary so lets say 5-23, which in one example could look like
*/20 5-23 * * * dh -h
#  @yearly  	(non-standard)
#  @annually	(non-standard)
#  @monthly 	(non-standard)
#  @weekly  	(non-standard)
#  @daily   	(non-standard)
#  @hourly	   (non-standard)
#  @reboot  	(non-standard)

#+END_SRC
** run 
#+BEGIN_SRC sh
  # 
  # run shell scripts 
  
  ./name.sh
  sh -x name.sh # debugging mode or Trouble shoot
  sh name.sh
  source name.sh

#+END_SRC
* Shell 
** Shabang
#+BEGIN_SRC sh
  #! /bin/bash
  #! /bin/sh     # #! :shabang
  echo "print in termnal"
#+END_SRC
** Variable
#+BEGIN_SRC sh
  #
  # varaiable 
  #

  # systax   <variable-name>=<value>
  # variable should consist of (a-z,A-Z,0-9, _ ) NO special symbol, variable should not start with number

  #EG:
  a=10
  b=15
  salary=10000
  name=sathish
  surname='script'
  lastname="script"         

  echo "$a"            # 10 print the variable
  echo "$b"            # 15
  echo "$salary"       # 10000
  echo "name"          # name 
  echo "$name"         # sathish
  echo "${name}"       # sathis
  echo '$name'         # $name
  echo "Hi my name is $name"      # Hi my name is sathish
  echo "Hi my name is ${name}"    # Hi my name is sathish
  echo "${surname}ing is fun"     #script is fun
  ending
  echo "This is ${word}${ending}. "

  #Ex : 
  #Eg : 
  src=/opt/sathish/scripts
  dest=/temp
  # will move sbi.war file from scr to dest
  cp $src/sbi.war $dest/

  # Ex : write a script which will clone from git_url to dest
  #Filename : clone.sh
  git_url= https://github.com/devipsstephen/ibm.git
  dest= /opt/git_repo
  mkdir -p $dest
  cd $dest
  pwd
  git clone $git_url
  chrontab -e
  # # insert
  # */1 * * * * sh /opt/clone.sh  

#+END_SRC

** Diff btw " and ' 
single quotes (') preserves the literal value of each character within the quotes. 
Enclosing characters in double quotes (") preserves the literal value of all characters within the quotes, with the exception of $, `, \,

#+BEGIN_SRC sh
echo "${name}"       # sathis
echo '$name'         # $name
#+END_SRC

** Special Variable
#+BEGIN_SRC sh
#!/bin/bash

#
#    UID
# 

# Display the UID and username of the user executing this script.
# Display if the user is the root user or not.

# Display the UID
echo "Your UID is ${UID}"    # UID special preset variable 
## >>> Your UID is 1000

# TO more about uid 
# man bash
# # vi key binding
#/UID<ENTER>

# Display the username
#USER_NAME=$(id -un)
USER_NAME=`id -un`    # older style 
echo "Your username is ${USER_NAME}"

# Display if the user is the root user or not.
if [[ "${UID}" -eq 0 ]]
then
  echo 'You are root.'
else
  echo 'You are not root.'
fi


#
#          ID
#
# Print user and group information for  the specified USER or (for current user

man id
type -a id
id -u
id -u -n
id -un

# whoami
man whoami

# [[ is bash condtion not work in csh shell may not work
# or 
# [  is older UNIX way


#+END_SRC

** PATH variable,  basename N dirname variable

The search path for commands.  
It is  a  colon-separated  list of directories  in  which  the  shell looks for commands
#+BEGIN_SRC sh
PATH=${PATH}:/opt/softwares/apache-maven-3.6.3/bin

path_maven= /opt/softwares/apache-maven-3.6.3 
basename /opt/softwares/apache-maven-3.6.3
# > apache-maven-3.6.3

dirname= /opt/softwares/apache-maven-3.6.3
# > /opt/softwares/

dirname= /opt/software/apache-maven-3.6.3/bin/not/here
# > /opt/softwar/apache-maven-3.6.3/bin/not
#+END_SRC

#+BEGIN_SRC sh

echo "You executeed in this command :${0}"

echo "You used $(dirname ${0}) as the path to $(basename ${0}) script"

NoOfParameter= "${#}"
echo "You supplied ${NoOfParameters} arguments(s) on the command line."

if [[ "${NoOfParameters}" -lt 1]]
then 
    echo "Usage : ${0} USER_NAmE [USER_NAmE]]"
    exit 1
fi

#+END_SRC

** IF statment 
#+BEGIN_SRC sh
  #
  # Decision making
  #

  #syntax:
  #if [condition]
  #then
  #
  #
  #else
  #
  #fi

  # relation operators
  # == eq ,>= ge ,<= le ,=! ne , < gt , > lt 

  #Ex

  age=20
  if [$age>=18] # or [ $age -ge 18]
  then
  echo "aligible for diving license"
  else
  echo "not aligible"
  fi



  #Ex : if file(calender.war) exist then backback
  src= /opt/calender.war
  dest=/opt/backup
  mkdir -p $dest

  if [-f $src]
     then
       mv $src $dest
       echo "file is existing"
       
  else
     cp /tmp/Calender.war $dest
     if [$? ==0]
        then 
          echo "deployment is done successfull"
     fi
  fi




  # Ex: Tell weather deployment is sucessfull or failure 
  sh deploy.sh

  if[ $? ==0]
  then
  echo "deployment is done sucessfull"
  else 
  echo "not success"
  if

# Ex : check if disk space of /dev/xvda1 is more the 3GB then clean the space

thershold=3
disc= `df-h |grep /dev/xvda1 | awk '{print 4}'| cut -c 1`
echo "$disc"

if [$disk -gt $threshold]
then 
   echo"clean the space"
else
   echo"disc space is ok"
fi


#+END_SRC

** Argument in shell
#+BEGIN_SRC sh
  # passing prameter in shell 
  # sh  tesh.sh 45 yes 25k shathish
  #then $0 is test.sh
  # ${0} is file name
  # ${1} is 45
  # ${2} is yes
  # ${3} is 25k
  # ${4} is shatish
  # $#   is No.Of parameter in command line or ${#}
  # $? : Exist Status of  previous cmd executed sucessfull : true / false(not exectued sucessfull)
  # "${@} : all parameter starting from 1 or ${1}${2}${3}${4}"
#+END_SRC
*** Argument Examples
#+BEGIN_SRC sh

echo "You executeed in this command :${0}"

echo "You used $(dirname ${0}) as the path to $(basename ${0}) script"
# dirname /home/jayradhe
## >>/home

# basename /home/jayrade
## >> jayradae


NoOfParameter= "${#}"
echo "You supplied ${NoOfParameters} arguments(s) on the command line."

if [[ "${NoOfParameters}" -lt 1]]
then 
    echo "Usage : ${0} USER_NAmE [USER_NAmE]]"
    exit 1
fi

# Generate and display a password for each parameter
do
 PASSWORD=$(date +%s%N | sha256sum | head -c48)
  echo "${USER_NAME}: ${PASSWORD}"
done
#+END_SRC

** READ 
read -p “ prompt_text”

Here we read the data along with some hint text . The hint text helps the user in what he/she has to enter . -p here stands for the prompt . The hint text also called the prompt text.
#+BEGIN_SRC sh
#!/bin/bash

# This script creates an account on the local system.
# You will be prompted for the account name and password.

# Ask for the user name.
read -p 'Enter the username to create: ' USER_NAME 

# Ask for the real name.
read -p 'Enter the name of the person who this account is for: ' USER_DETAILS

# Ask for the password.
# read -p 'Enter the password to use for the account: ' PASSWORD

read -s -p "Enter Password: " password
echo $password

# Create the user.
useradd -c "${USER_DETAILS}" -m ${USER_NAME}

# Set the password for the user.
# NOTE: You can also use the following command:
#    echo "${USER_NAME}:${PASSWORD}" | chpasswd
echo ${PASSWORD} | passwd --stdin ${USER_NAME}

# Force password change on first login.
passwd -e ${USER_NAME}
#+END_SRC
** RANDOm 
#+BEGIN_SRC sh
#!/bin/bash

# This script generates a list of random passwords.

# A random number as a password.
PASSWORD="${RANDOM}"
echo "${PASSWORD}"

# Three random numbers together.
PASSWORD="${RANDOM}${RANDOM}${RANDOM}"
echo "${PASSWORD}"

# Use the current date/time as the basis for the password.
PASSWORD=$(date +%s)
echo "${PASSWORD}"

# Use nanoseconds to act as randomization.
PASSWORD=$(date +%s%N)
echo "${PASSWORD}"

# A better password.
PASSWORD=$(date +%s%N | sha256sum | head -c32)
echo "${PASSWORD}"

# An even better password.
PASSWORD=$(date +%s%N${RANDOM}${RANDOM} | sha256sum | head -c48)
echo "${PASSWORD}"

# Append a special character to the password.
SPECIAL_CHARACTER=$(echo '!@#$%^&*()_-+=' | fold -w1 | shuf | head -c1)
echo "${PASSWORD}${SPECIAL_CHARACTER}"

# shuf 
echo "karthik" | fold -w1                # print each character in order
echo "karthik" | fold -w1| shuf          # print each character in random order
echo "karthik" | fold -w1| shuf |head -c1 # print one character in random
 
#+END_SRC
** RANDOm II
#+BEGIN_SRC sh
#!/bin/bash

# This script generates a random password for each user specified on the comand line.

# Display what the user typed on the command line.
echo "You executed this command: ${0}"

# Display the path and filename of the script.
echo "You used $(dirname ${0}) as the path to the $(basename ${0}) script."

# Tell them how many arguments they passed in.
# (Inside the script they are parameters, outside they are arguments.)
NUMBER_OF_PARAMETERS="${#}"
echo "You supplied ${NUMBER_OF_PARAMETERS} argument(s) on the command line."

# Make sure they at least supply one argument.
if [[ "${NUMBER_OF_PARAMETERS}" -lt 1 ]]
then
  echo "Usage: ${0} USER_NAME [USER_NAME]..."
  exit 1
fi

# Generate and display a password for each parameter.
for USER_NAME in "${@}"
do
  PASSWORD=$(date "+%s %N" | sha256sum | head -c48)
  echo "${USER_NAME}: ${PASSWORD}"
done
#+END_SRC

** Example 
deployment process:
- step 1:
   - check file is existing or not is /opt
   - if yes :take back up to buackup folder
   - if no 
      - cp new war file to deployment folder /opt
or
#+BEGIN_SRC sh
if [ -f /opt/Calender.war]
then
# if exist
mv
# create file copy
else
   #cp
fi
#+END_SRC
** Example 
deployment :
To developers
To System Integration and Testing
To Preproduction
To production 

#+BEGIN_SRC sh
#! /bin/sh
#FILEName : deployment.sh
env = $1
if ['dev' = $env ] &&[/opt/Calender.war]
then 
cp /tem/*.war /opt/dev
fi

if ['sit' = $env ]
then 
cp /tem/*.war /opt/sit
fi
if ['preprod' = $env ]
then 
cp /tem/*.war /opt/preprod
fi
if ['prod' = $env ]
then 
cp /tem/*.war /opt/prod
fi

## sh deployment.sh sit
#+END_SRC
** If Condition Statment
#+BEGIN_SRC sh
#!/bin/bash

This script demonstrates the case statement.

Instead of an if statement like this, consider using a case statement instead.
if [[ "${1}" = 'start' ]]
then
  echo 'Starting.'
elif [[ "${1}" = 'stop' ]]
then
  echo 'Stopping.'
elif [[ "${1}" = 'status' ]]
then
  echo 'Status:'
else
  echo 'Supply a valid option.' >&2
  exit 1
fi
#+END_SRC

#+BEGIN_SRC sh
! /bin/bash
file=$1
if [ -e $file ]
then
	echo -e "File $file exists"
else
	echo -e "File $file doesnt exists"
fi
#+END_SRC

#+BEGIN_SRC sh
#!/bin/bash
echo "Please enter first number"
read first
echo "Please enter second number"
read second

if [ $first -eq 0 ] && [ $second -eq 0 ]
then
	echo "Num1 and Num2 are zero"
elif [ $first -eq $second ]
then
	echo "Both Values are equal"
elif [ $first -gt $second ]
then
	echo "$first is greater than $second"
else
	echo "$first is lesser than $second"
fi
#+END_SRC

#+BEGIN_SRC sh
if [ “$1” == “moo” ] 
then
    echo "$1 is moo" 
fi
# Note: you can also use a single “=” instead of a double one.
#+END_SRC

#+BEGIN_SRC sh

if [ `whoami` != 'root' ]; then
	echo "Executing the installer script"
else
	echo "Root is not allowed to execute the installer script"
fi
#+END_SRC
** If vs Switch 
#+BEGIN_SRC sh
!/bin/bash

This script demonstrates the case statement.

Instead of an if statement like this, consider using a case statement instead.
if [[ "${1}" = 'start' ]]
then
  echo 'Starting.'
elif [[ "${1}" = 'stop' ]]
then
  echo 'Stopping.'
elif [[ "${1}" = 'status' ]]
then
  echo 'Status:'
else
  echo 'Supply a valid option.' >&2
  exit 1
fi

This ideal format of a case statement follows.
case "${1}" in
  start)
    echo 'Starting.'
    ;;
  stop)
    echo 'Stopping.'
    ;;
  status|state|--status|--state)
    echo 'Status:'
    ;;
  *)
    echo 'Supply a valid option.' >&2
    exit 1
    ;;
esac


Here is a compact version of the case statement.

case "${1}" in
  start) echo 'Starting.' ;;
  stop) echo 'Stopping.' ;;
  status) echo 'Status:' ;;
  *)
    echo 'Supply a valid option.' >&2
    exit 1
    ;;
esac

#+END_SRC

#+BEGIN_SRC sh

# This ideal format of a case statement follows.
case "${1}" in
  start)
    echo 'Starting.'
    ;;
  stop)
    echo 'Stopping.'
    ;;
  status|state|--status|--state)
    echo 'Status:'
    ;;
  *)
    echo 'Supply a valid option.' >&2
    exit 1
    ;;
esac



#+END_SRC
**  Switch Statment II
#+BEGIN_SRC sh
# Here is a compact version of the case statement.
case "${1}" in
  start) echo 'Starting.' ;;
  stop) echo 'Stopping.' ;;
  status) echo 'Status:' ;;
  *)
    echo 'Supply a valid option.' >&2
    exit 1
    ;;
esac
#+END_SRC
** for Loop
The `for' loop executes a sequence of commands for each member in list of items.  
If `in WORDS ...;' is not present, then `in "$@"' is assumed.  
For each element in WORDS, NAME is set to that element, and the COMMANDS are executed.

more information man bash #vi /Specia Parameters  or @

#+BEGIN_SRC sh
# for $vari in 1 2 3 4 5 
# do
# #statement
#done

#! i in 1 2 3 4 5 
for i in 1 2 3 4 5
do 
  echo "$i"
  echo "$i"
done

cat name
#sathish
#sanjay
#prabhakar
#karthik
#vijay
#santhosh
#prasad
#ravi
#raa
#ggg
#hh
#kk

# for i in $(cat people_data.csv); do  echo "$i"; done
for i in `cat name`
do
echo "$i"
done

touch test 
vi test 
# welcom 
cp test test2
cp test test3

#FileName: file.sh
#! /bin/sh

for file in /d/chola/*
do 
   if ["${file}" == "/d/chola/test"]
      then
       sed -i 's/welcome/devops/g'
      fi
done


for i in `cat /d/chola/test`
do
  echo "$i" |sed -i 's/welcome/devops/g'
done
#+END_SRC

** while and Shift loop
#+BEGIN_SRC sh
#!/bin/bash

# Demonstrate the use of shift and while loops.

# Display the first three parameters.
echo "Parameter 1: ${1}"
echo "Parameter 2: ${2}"
echo "Parameter 3: ${3}"
echo

# Loop through all the positional parameters.
while [[ "${#}" -gt 0 ]]
do
  echo "Number of parameters: ${#}"
  echo "Parameter 1: ${1}"
  echo "Parameter 2: ${2}"
  echo "Parameter 3: ${3}"
  echo
  shift
done


#+END_SRC

** Switch 
#+BEGIN_SRC sh  syntax
env=moday
case "$env" in 

"monday") echo "monday";;
"tuesday") echo "tuesday";;
"*") echo "invalid opearation"
esac
#+END_SRC

#+BEGIN_SRC sh 
#! /bin/sh
day= $1
case $day in 
"monday") 
echo "this is monday"
;;
case $day in 
"tue") 
echo "this is tuesday"
;;
"*")
echo "invalid"
;;
esac

#+END_SRC

** Function

#+BEGIN_SRC sh
env = $1

# delete all files in tmp fodler
delete()
{
rm -rf /tmp/*
}

# copy sbi.war file to username at ip:x.x.x.x  at /tmp

deploy()
{username= $1
passwd=$2
scp sbi.war $username@$passwd: /tmp
}

if evn == dev
then 
deploy dev 192.145.67.8
fi 

if evn == sit     # System Integration and Testing
then 
deploy dev 192.145.67.8
fi 

if evn == preprod
then 
deploy dev 192.145.67.8
fi 

if evn == prod
then 
deploy dev 192.145.67.8
fi 

#+END_SRC

#+BEGIN_SRC sh
log(){
# local: The  scope variable inside func exist
# "${@} : all parameter starting from 1 or ${1}${2}${3}${4}"

local message= "${@}"
echo "${message}" 
}
log 'Hello!'
log 'This is fun'

# Or
function log{
  echo 'You called the log function'
}
#+END_SRC
*** Example
#+BEGIN_SRC sh
  log(){
   local VERBOSE="${1}"
   shift
   local message= "${@}"         
   if [["${VERBOSE}"= 'true' ]]
   then 
       echo "${message}"
   fi 
  }
  log 'true' 'Hello!'

  VERBOSE='true'
  log "${VERBOSE}" 'Hello!'
  log "${VERBOSE}" 'This is fun'

  # 
  #       READ ONLY VARIABE
  #
  log(){
   local message= "${@}"         
   if [["${VERBOSE}"= 'true' ]]
   then 
       echo "${message}"
   fi 
  }

  readonly VERBOSE='true'
  log  'Hello!'
  log 'This is fun'


  #
  #    Send msg to sys logger
  #
  type -a logger
  man logger
  logger 'Hello from udemy course this is linux course'
  sudo tail /var/log/messages

  logger -t myscript 'Tagging on'

#+END_SRC
*** Functoin for backup files
#+BEGIN_SRC sh
#!/bin/bash

# This script demonstrates the use of functions.

log() {
  # This function sends a message to syslog and to standard output if VERBOSE is true.

  local MESSAGE="${@}"
  if [[ "${VERBOSE}" = 'true' ]]
  then
    echo "${MESSAGE}"
  fi
  logger -t luser-demo10.sh "${MESSAGE}"
}

backup_file() {
  # This function creates a backup of a file.  Returns non-zero status on error.

  local FILE="${1}"

  # Make sure the file exists.
  if [[ -f "${FILE}" ]]
  then
    local BACKUP_FILE="/var/tmp/$(basename ${FILE}).$(date +%F-%N)"
    log "Backing up ${FILE} to ${BACKUP_FILE}."

    # The exit status of the function will be the exit sta tus of the cp command.
    cp -p ${FILE} ${BACKUP_FILE}
  else
    # The file does not exist, so return a non-zero exit status.
    return 1
  fi
}

readonly VERBOSE='true'
log 'Hello!'
log 'This is fun!'

backup_file /etc/passwd

# Make a decision based on the exit status of the function.
# Note this is for demonstration purposes.  You could have
# put this functionality inside of the backup_file function.
if [[ "${?}" -eq '0' ]]
then
  log 'File backup succeeded!'
else
  log 'File backup failed!'
  exit 1
fi
#+END_SRC
** Regular expression 
Regular Expression
 - Flexible search pattern
 - made up of:
   - anchors        - specify
   - character sets - what is searched
   - modifiers      - specify  how many times the previous character set  is repeted
|-----------+--------------------------------------------------------------------|
| ANCHORS   |                                                                    |
|-----------+--------------------------------------------------------------------|
| .(period) | any char except '\n'                                               |
| ^         | matches start of string                                            |
| *         | matches up zero or more time the preceding character               |
| $         | matches end of string                                              |
| \         | Represent special  character                                       |
| ()        | Group of regural Expression                                        |
| ?         | match up exactly one character                                     |
| {n}       | matches the preceding char appearing 'n' times exactly             |
| {n,m}     | matches the preceding char appearing 'n' times but not more than m |
| {n,}      | matches the preceding char appearing 'n' times or more             |
|           |                                                                    |

Extended Regular Expression
| \+ | matches one or more occurrence of the previous character |
| \? | matches zero or one occurrence of previous character     |
| {} | Brace Expression                                        |


#+BEGIN_SRC sh
cat sample |grep ^a  #
cat sample | grep t$
echo -e "apple\npant\npeople" |grep -E p\{2}   # apple 
echo -e "bat\nant\neat\npant\ntaste" | grep "a\+t" # bat, eat

echo -e "bat\nhat\nrat\nsat\neat\npeople" |grep '[b,h]at'
#bat
#hat
# asdfbatadfadsd
# adfahatadfad

echo -e "0324-241-341" |grep '[0-9][0-9][0-9][0-9]'
# 0324-241-341
echo -e "0324-241-341" |grep -oP '[0-9]{3}'
# 032
# 241
# 341

grep -n ^'work' GNULicense.txt # line starting with work
grep -n 'work'$ GNULicense.txt # line ending with work
grep -n 'th..' GNULicense.txt 
#the that this....etc
#Exception want to search for []
grep -n '\[\]' GNULicense.txt
grep -n '\<work\>' GNULicense.txt # search for word "work" with no starting and ending extentions

# global serach using regular expression
# grep -i # ignore case
# grep -
#+END_SRC

** cut and Awk
#+BEGIN_SRC sh
#type -c 1 <file_name> type -a cut # cut is not a shell build in but
stand alone property man cut

cut -c 1 /etc/passwd 
cut -c 4-7 /etc/passwd 
cut -c 4- /etc/passwd 
cut -c 1,3,5,9 /etc/passwd 
cut -c 1 /etc/passwd 
echo "aefdadsfa\tasfadfad"  #>>> aefdadsfa\tasfadfad 
echo -e "aefdadsfa\tasfadfad" #>>> aefdadsfaasfadfad 
echo -e "aefdadsfa\nasfadfad" #>>> aefdadsfa #asfadfad
echo -e 'one\ttwo\tthree'| cut -f 1 # f : field 
echo -e  'one\ttwo\tthree'| cut -f 2 # f : field 
echo -e 'one\ttwo\tthree'| cut -f 3 # f : field
 
echo 'one,two,three' |cut -d ',' -f 1 # correct way to do 
echo  'one,two,three' |cut -d , 2 # Error 
echo 'one,two,three' |cut -d, 3 #  Error 
echo 'one\two\three' |cut -d \ 3 #ERROR : 
echo 'one\two\three'  |cut -d '\' -f 3 #Correct way

  # print the uid of password in/etc/passwrd 
cut -d ':' -f 1,3  /etc/passwd 
echo 'first,last' > people.csv 
echo 'John,Smitt'>>people.csv 
echo 'firstly,masdfaf' >>people.csv 
echo 'mr.john,sim'  >>people.csv 
cat peopel.csv 
cut -d ',' -f 1 people.csv
grep 'first' people.csv 
grep 'first,last' people.csv
grep '^first' people.csv # start with first 
grep 't$' people.csv# end  #   with t 
grep -v '^first,last' peopel.csv # doesn't match w
grep -v '^first,last' peopel.csv |cut -d ',' -f1 John firstlylsmr.firstly

  #or cut -d ',' -f people | grep -v '^first$' # regexp are be used on
  grep command

cat people_data.csv Data: firstData:last Data: JohnData:Smitt Data:
  firstlyData:mclasty Data: mr.firstlyData:mclasty 
cut -d ':' -f 2 people_data.csv # above peopel_data we can't seperate it only by using
cut but we can do it by awk command

awk -F {Data:} '{print $2}' people_data.csv

# Example :
cut -d ':' -f 1,3 /etc/passwd 
awk -F ':' '{print $1, $3}' /etc/passwd # here , is space in output
awk -F ':' '{print $1$3}' /etc/passwd # here , is space in output
# awk has special variable called OFS:Output Field Seperator


# to change the variable in awk use -v option
awk -F ':' -v OFS=',' '{print $1,$3}' /etc/passwd
awk -F ':' '{print "COL: " $1 $3}' /etc/passwd
# cut : can't arrange the order in which it print output
# awk : can do it
cut -d ':' -f 3,1 /etc/passwd
awk -F ':' '{print $3,$1}' /etc/passwd
awk -F ':' '{print "UID: " $3 "LOGIN:" $1}' /etc/passwd

# PRINT LAST (FIELD or Colum)
awk -F ':' '{print $NF}' /etc/passwd
awk -F ':' '{print $(NF-1)}' /etc/passwd

  #
  # Example : 
  #
  history > sqlcommands
  sed 's/^[ ]*[0-9]*[ ]//' sqlcommands > sqlcommands2 
  #
  #
  history | cut -c 8-
  history | awk '{$1="";print substr($0,2)}'
  history | sed 's/^[ ]*[0-9]\+[ ]*//'
  history | awk '{$1="";print}'
  history | awk '{$1="";print $0 }'

  # alias history="history | sed 's/^[ ]*[0-9]\+[ ]*//'"




  #
  #  Irregular or improper arrangement of to data
  #
  echo 'L1C1     L1C2' > lines
  echo '    L2C1 L2C2   '>> lines
  echo '  L3C1    L3C2 '  >>lines
  echo -e 'L4C1\tl4c2'  >>lines

  cat lines

  awk '{print $1,$2}' lines 
#+END_SRC

*** Exampel : Find all Network pork using Awk 
#+BEGIN_SRC sh
#!/bin/bash

# This script shows the open network ports on a system.
# Use -4 as an argument to limit to tcpv4 ports.

netstat -nutl ${1} | grep : | awk '{print $4}' | awk -F':' '{print $NF}'
#+END_SRC
** Sort and uniq 
#+BEGIN_SRC sh
sort /etc/passwd |less
sort -r /etc/passwd  # print in reverse order
# sort with numbers
cut -d ':' -f 3 /etc/passwd | sort   # not sorted numerically
cut -d ':' -f 3 /etc/passwd | sort -n  # sort by nubmer
cut -d ':' -f 3 /etc/passwd | sort -nr  # reverse sort

#
# du : disk usage
# 
sudo du /var # two colum , 1st colum: amount of memory used in KB ,2nd colum: which dir used space
sudo du -h /var # human readable form 

# print in space in order
sudo du -h /var |sort  # not sorted in numeriacally order
sudo du -h /var |sort -n
sudo du -h /var |sort -h



# sort prot (may consist of dublicates)
netstat -nutl  | grep ':' | awk '{print $4}'| awk -F ':' '{print $NF}'|sort -n

# sort with unique or(no dublicates)
netstat -nutl  | grep ':' | awk '{print $4}'| awk -F ':' '{print $NF}'|sort -nu
#or 
# sort with unique or(no dublicates)
netstat -nutl  | grep ':' | awk '{print $4}'| awk -F ':' '{print $NF}'|sort -n|  uniq 

# NOT Unique : doesn't support without sort (sort -n)


# Know who many occurance or count
netstat -nutl  | grep ':' | awk '{print $4}'| awk -F ':' '{print $NF}'|sort -n|  uniq -c

# How many times sys log is generating
sudo cat /var/log/messages | awk '{print $5}'|sort| uniq-c| sort -n


# what are the ip which are hitting the most

 wc /etc/passwd
wc -w /etc/passwd       # word count -w
wc -c /etc/passwd       # byte count -c
wc -l /etc/passwd       # line conut -l

# How many accout are using bash shell
grep bash /etc/passwd | wc -l
grep -c bash /etc/passwd

# sort passwd using uid (3 colum)
cat /etc/passwd | sort -t ':' -k 3 -n -r 
# by default sort uses "white space" as field seperator but 
# we can specify the field seperator by 't'
# which field should be used ? is given by key 

cat access_log |cut -d '"' -f 2 # or 
cut -d '"' -f 2 access_log |cut -d ' ' -f 2
awk '{print $7}' acess_log
cut -d '"' -f 2 access_log |cut -d ' ' -f 2| sort|uniq -c |sort -n
# display top 3 cmd
cut -d '"' -f 2 access_log |cut -d ' ' -f 2| sort|uniq -c |sort -n|tail -3
#+END_SRC

#+BEGIN_SRC sh
#!/bin/bash

# Display the top three most visited URLs for a given web server log file.

LOG_FILE="${1}"
#
# check if log file exist
# 
if [[ ! -e "${LOG_FILE}" ]] # Not existing file 
then
  echo "Cannot open ${LOG_FILE}" >&2
  exit 1
fi

cut -d '"' -f 2 ${LOG_FILE} | cut -d ' ' -f 2 | sort | uniq -c | sort -n | tail -3
#+END_SRC

*** Exersice 
**** Goal:
The goal of this exercise is to create a shell script that displays the number of failed login attempts
by IP address and location.
**** Scenario:
One day you received a call about a user being locked out of their account. Being the awesome
sysadmin that you are, you decided to look at the log files to see why this person's account was
locked. While doing so, you happened to notice hundreds thousands of failed login attempts!
You decide you need a way to quickly summarize the failed login attempts. That way you can
quickly decide if an IP address needs to blocked.
**** Shell Script Requirements:
You think about what the shell script must do and how you would like it operate. You come up with
the following list.

**** The script:
- Is named "show-attackers.sh ".
- Requires that a file is provided as an argument. If a file is not provided or it cannot be read, then the script will display an error message and exit with a status of 1.
- Counts the number of failed login attempts by IP address. If there are any IP addresses with more than 10 failed login attempts, the number of attempts made, the IP address from which those attempts were made, and the location of the IP address will be displayed.
  - Hint: use the geoiplookup command to find the location of the IP address.
- Produces output in CSV (comma-separated values) format with a header of "Count,IP,Location".
**** Solution
#+BEGIN_SRC sh
# look contant of file
cat /home/jayradhe/Workspace/Linux_script/udemy_exercises/syslog-sample 

grep 'Failed' syslog-sample | awk -F 'from ' '{print $2}'|cut -d ' ' -f 1 #or
grep 'Failed' syslog-sample | awk -F 'from ' '{print $2}'|awk '{print $1}' 
#or
grep 'Failed' syslog-sample | awk '{print $(NF -3)}'|sort|uniq -c|sort -nr

# find ip address 
geoiplookup 182.100.67.59

grep 'Failed' syslog-sample | awk '{print $(NF -3)}'|sort|uniq -c|sort -nr| whle read COUNT IP
do 
# If no.of failed attempts is greater than limit , display count,Ip,Location
  if [[ "${COUNT}" -gt 10 ]]
  then
#    Location = $(geoiplookup ${IP})
    Location = $(geoiplookup ${IP} | awk -F ', ' '{print $2}') # remove umwanted data
#    echo "${COUNT} ${IP} $ {LOCATION}"
    echo "${COUNT}, ${IP}, $ {LOCATION}"
  fi
done
####################################################################
#!/bin/bash

# Count the number of failed logins by IP address.
# If there are any IPs with over LIMIT failures, display the count, IP, and location.

LIMIT='10'
LOG_FILE="${1}"

# Make sure a file was supplied as an argument.
# 
if [[ ! -e "${LOG_FILE}" ]]
then 
  echo "Cannot open log file: ${LOG_FILE}" >&2
  exit 1
fi

# Display the CSV header.
echo 'Count,IP,Location'

# Loop through the list of failed attempts and corresponding IP addresses.
grep Failed ${LOG_FILE} | awk '{print $(NF - 3)}' | sort | uniq -c | sort -nr |  while read COUNT IP
do
  # If the number of failed attempts is greater than the limit, display count, IP, and location.
  if [[ "${COUNT}" -gt "${LIMIT}" ]]
  then
    LOCATION=$(geoiplookup ${IP} | awk -F ', ' '{print $2}')
    echo "${COUNT},${IP},${LOCATION}"
  fi
done
exit 0
#+END_SRC
** Sed and Streams (find and replace)
 Sed = Stream editor
A stream is data that travels from :
- One process to another through a pip
- One file to another as a redirect
- One device to another.

Standard Input = Standard Input Stream, etc
Strems are typically textual data

Sed perform text transformations on streams
Example :
 - Substitute some text for other text
 - Remvoe lines
 - Append textg after given lines
 - Insert text before certain lines

Sed is used programmatically,not interactively
sed is 
#+BEGIN_SRC sh
## syantax : sed's/search-pattern/replacement-string/flags'
echo 'Dwight is the assistant regional manager.' > manager.txt
cat manager.txt
sed 's/assistant/assistant to the/' manager.txt# s :substitute cmd
# sed also allow regex for search and repalce

# the original file is not alter or change
 cat manager.txt

# to change original file
sed 's/assistant/assistant to the/' manager.txt


# Case insensitive :
echo 'I love my prabhupad' love.txt
sed 's/PRABHUPAD/HH A.C.PRABHUPAD/i' love.txt
echo 'This is line2' >> love.txt 

# By default sed replace first pattern on line  but not on whole line or multi accurance in same line .
# replace  muti-occurance we use g-flage
sed 's/PRABHUPAD/HH A.C.PRABHUPAD/g' love.txt
sed 's/PRABHUPAD/HH A.C.PRABHUPAD/2' love.txt # only 2nd occarance is changed

# create a backup
sed -i.bak  's/assistant/assistant to the/' manager.txt


#+END_SRC
** Deletig and Disabling Linux
type -a userdel    # not found
which userdel      # no userdel in 
3) options : userdel cmd is outside the path of shell 
#+BEGIN_SRC sh


#+END_SRC
** I/O redirection 

#+BEGIN_SRC sh
#!/bin/bash

# This script demonstrates I/O redirection.

# Redirect STDOUT to a file.
FILE="/tmp/data"
head -n1 /etc/passwd > ${FILE}

# Redirect STDIN to a program.
read LINE < ${FILE}
echo "LINE contains: ${LINE}"

# Redirect STDOUT to a file, overwriting the file.
head -n3 /etc/passwd > ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}

# Redirect STDOUT to a file, appending to the file.
echo "${RANDOM} ${RANDOM}" >> ${FILE}
echo "${RANDOM} ${RANDOM}" >> ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}

# Redirect STDIN to a program, using FD 0.
read LINE 0< ${FILE}
echo
echo "LINE contains: ${LINE}"

# Redirect STDOUT to a file using FD 1, overwriting the file.
head -n3 /etc/passwd 1> ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}

# Redirect STDERR to a file using FD 2.
ERR_FILE="/tmp/data.err"
head -n3 /etc/passwd /fakefile 2> ${ERR_FILE}
echo
echo "Contents of ${ERR_FILE}:"
cat ${ERR_FILE}

# Redirect STDOUT and STDERR to a file.
head -n3 /etc/passwd /fakefile &> ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}

# Redirect STDOUT and STDERR through a pipe.
echo
head -n3 /etc/passwd /fakefile |& cat -n

# Send output to STDERR
echo "This is STDERR!" >&2

# Discard STDOUT
echo
echo "Discarding STDOUT:"
head -n3 /etc/passwd /fakefile > /dev/null

# Discard STDERR
echo
echo "Discarding STDERR:"
head -n3 /etc/passwd /fakefile 2> /dev/null

# Discard STDOUT and STDERR
echo
echo "Discarding STDOUT and STDERR:"
head -n3 /etc/passwd /fakefile &> /dev/null

# Clean up
rm ${FILE} ${ERR_FILE} &> /dev/null


#+END_SRC

** Parsing Command Line Option (getopts)
#+BEGIN_SRC sh
# getopts is builtin #type -a getopts
# help getopts | less
# Getopts is used by shell procedures to parse position parameters
#!/bin/bash

# This script generates a random password.
# The user can set the password length with -l and add a special character with -s.

# Verbose mode can be enabled with -v.

usage() {
  echo "Usage: ${0} [-vs] [-l LENGTH]" >&2
  echo 'Generate a random password.' >&2
  echo '  -l LENGTH  Specify the password length.' >&2
  echo '  -s         Append a special character to the password.' >&2
  echo '  -v         Increase verbosity.' >&2
  exit 1
}

log() {
  local MESSAGE="${@}"
  if [[ "${VERBOSE}" = 'true' ]]
  then
    echo "${MESSAGE}"
  fi
}

# Set a default password length.
LENGTH=48

while getopts vl:s OPTION
do
  case ${OPTION} in
    v)
      VERBOSE='true'
      log 'Verbose mode on.'
      ;;
    l)
      LENGTH="${OPTARG}"
      ;;
    s)
      USE_SPECIAL_CHARACTER='true'
      ;;
    ?)
      usage
      ;;
  esac
done

# Remove the options while leaving the remaining arguments.
shift "$(( OPTIND - 1 ))"

if [[ "${#}" -gt 0 ]]
then
  usage
fi

log 'Generating a password.'

PASSWORD=$(date +%s%N${RANDOM}${RANDOM} | sha256sum | head -c${LENGTH})

# Append a special character if requested to do so.
if [[ "${USE_SPECIAL_CHARACTER}" = 'true' ]]
then
  log 'Selecting a random special character.'
  SPECIAL_CHARACTER=$(echo '!@#$%^&*()_-+=' | fold -w1 | shuf | head -c1)
  PASSWORD="${PASSWORD}${SPECIAL_CHARACTER}"
fi

log 'Done.'
log 'Here is the password:'

# Display the password.
echo "${PASSWORD}"

exit 0

#+END_SRC
** Redirect a file 
Every process three File Descriptors :
- FD 0 STDIN  # Input
- FD 1 STDOUT # output
- FD 2 STDERR # error 

#+BEGIN_SRC sh
id -un > id
"${UID}" > uid

# set password from file/variable
echo "secret" > password
sudo pass --stdin einstein < password

# create a password 
data | sha256sum | head -c10 >> password

######################################################33
# Redirect STDOUT to a file.
######################################################33

FILE="/tmp/data"
head -n1 /etc/passwd > ${FILE}

######################################################33
# Redirect STDIN to a program.
######################################################33

read LINE < ${FILE}
echo "LINE contains: ${LINE}"

######################################################33
# Redirect STDOUT to a file, overwriting the file.
######################################################33

head -n3 /etc/passwd > ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}

echo "secret" > password_file
cat password_file


######################################################33
# Redirect STDOUT to a file, appending to the file
######################################################33
echo "${RANDOM} ${RANDOM}" >> ${FILE}
echo "${RANDOM} ${RANDOM}" >> ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}


READ X < /etc/centos-release   # implicit and 
READ X 0< /etc/centos-release  # explicit
READ X 0 < /etc/centos-release # SYANTAX ERROR
echo "${UDI}" > uid
echo "${UDI}" 1> uid

man head # print 1st 10 lines of each File to standard output, with more tha t 1file
head  -n1 /etc/passwd /etc/hosts

# If file not exis then 

head  -n1 /etc/passwd /etc/hosts /etc/fakefile  
# output in terminal is : Has both std output and std error message
# STDOUTPUT : Are stored in head.out
# STDERROR : Are stored in head.err

########################################################33
# RE DIRECT : STDOUT, and print STDERROR
#######################################################33 
head  -n1 /etc/passwd /etc/hosts /etc/fakefile > head.out # Error message is re-directed to head.out but printed in terminal

########################################################33
# RE DIRECT : STDERROR
#######################################################33 
head  -n1 /etc/passwd /etc/hosts /etc/fakefile 2> head.err # Error message is re-directed to head.out but printed in terminal

#######################################################33#
# RE DIRECT : STDOUT and STDERROR :to seperate files
#######################################################33 
head  -n1 /etc/passwd /etc/hosts /etc/fakefile > head.out 2>head.err

########################################################33
# RE DIRECT : STDOUT and STDERROR :to seperate files
#######################################################33 
head  -n1 /etc/passwd /etc/hosts /etc/fakefile > head.both 2>&1 #re-direct FD2 at address of Fd1
# OR  (New way )
head  -n1 /etc/passwd /etc/hosts /etc/fakefile &> head.both
head  -n1 /etc/passwd /etc/hosts /etc/fakefile &>> head.both # append

#######################################################33
#  Append STD ERROR to STD OUT  : Doesn't flow(pass) through pipe
######################################################33# 
man cat 
head  -n1 /etc/passwd /etc/hosts /etc/fakefile | cat -n # Error: can't pass err msg

# inorder to pass error throw pip we need to append pass stderr to stdout
head  -n1 /etc/passwd /etc/hosts /etc/fakefile 2>&1 | cat -n  # Or
head  -n1 /etc/passwd /etc/hosts /etc/fakefile |& cat -n 

#######################################################33
#  Append STD OUT to STD ERROR  : Doesn't flow(pass) through pipe
######################################################33# 
echo "error" |cat -n
echo "error" >&2 |cat -n   #or
echo "error" 1>&2 |cat -n   # same as >&2
# Why we need to send data from std out to std error ?
# To echo a msg which stdout  to std error 
#Ex:
echo "This is a std error" >&2

######################################################33
# Redirect STDIN to a program, using FD 0.
######################################################33
read LINE 0< ${FILE}
echo
echo "LINE contains: ${LINE}"

######################################################33
# Redirect STDOUT to a file using FD 1, overwriting the file.
######################################################33
head -n3 /etc/passwd 1> ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}

######################################################33
# Redirect STDERR to a file using FD 2.
######################################################33
ERR_FILE="/tmp/data.err"
head -n3 /etc/passwd /fakefile 2> ${ERR_FILE}
echo
echo "Contents of ${ERR_FILE}:"
cat ${ERR_FILE}
######################################################33
# Redirect STDOUT and STDERR to a file.
######################################################33
head -n3 /etc/passwd /fakefile &> ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}

######################################################33
# Redirect STDOUT and STDERR through a pipe.
######################################################33
echo
head -n3 /etc/passwd /fakefile |& cat -n

######################################################33
# Send output to STDERR
######################################################33
echo "This is STDERR!" >&2

######################################################33
# Discard STDOUT
######################################################33
echo
echo "Discarding STDOUT:"
head -n3 /etc/passwd /fakefile > /dev/null

######################################################33
# Discard STDERR
######################################################33
echo
echo "Discarding STDERR:"
head -n3 /etc/passwd /fakefile 2> /dev/null

######################################################33
# Discard STDOUT and STDERR
######################################################33
echo
echo "Discarding STDOUT and STDERR:"
head -n3 /etc/passwd /fakefile &> /dev/null

######################################################33
# Clean up
######################################################33
rm ${FILE} ${ERR_FILE} &> /dev/null


#+END_SRC
** SSH (with password N with ssh-key)
*** Permissions on private key in ssh folder 
- Typically you want the permissions to be:
 - .ssh directory: 700 (drwx------)
 - public key (.pub file): 644 (-rw-r--r--)
 - private key (id_rsa): 600 (-rw-------)
*** Connect using SSH User Account - with Password 
#+BEGIN_SRC sh
ssh username@ip
scp file_path username@ip:dst_path
#+END_SRC

*** Connect using SSH-key (without using password)
During connect using SSH-Key there will be one master user(server) and slave server.
From master server we need to generate(ssh-key) and share to slave server and use ssh-key to connect slave server


- Step to connect using SSH-Key 
 - (Best Practice common user for all users (master and slave))
 - Give root privilege to common-user for both master and slave
 - Enable ssh-key based authentication( and restart sshd server)
 - Create ssh-key in master 
 - share(copy) ssh-key to slave
 - check ssh without password
#+BEGIN_SRC sh
# 1.best practice create one common users or genereal users

useradd devops
passwd devops
dev@123
# check see if password is created
cat /etc/passwd  #devips:x;1001.......etc


# 2.Give root permission for users
vi visudo
# add below lines 
 
## Allow root to run any commands anywhere
# devops ALL=(ALL)      Nopasswd : ALL


# 3. we use map key  should used as authentication
vi /etc/ssh/sshd_config
#PasswordAuthentication  yes


# 4.service sshd restart
service sshd restart

# 5.Connect master to slave with password
    # Crearte a common user is both master and slave
    # login to common-user from master
sudo su devops
# 6.Create ssh-key
ssh-keygen 
# 7.Copy ssh-key
scp-copy-id <user-name>@ip
########## DONE #############

# Connect master to slave using ssh without password
ssh devops@slave_ip 

# Connect slave to master 


# show-key : cat /home/<user-name>/devops/.ssh/authorizzed_keys
exit() # to exist 
#NOTE: we can connect from master to slave but not from slave to master
#+END_SRC

Exercies : create 5 servers in aws 
(build,dev,sit(System Integration and Testing),uat(UAT (User Acceptance Testing)),prod) servers and create common user(user:devops passwd: dev@!23)

Ques)make build as master and (dev,sit,uat,prod) as slave
Ans) build server (keygen, ssh-copy-id to dev,sit,uat,prod) 

From build server build war file and deploy to (dev,sit,uat,prod) script
#+BEGIN_SRC sh
#! /bin/bash
username= $1
ip= $2
env= $3

src_path= /opt/sbi.war
dst_path= /opt
if [$env =="dev"]
then
  scp $scr_path $username@$ip:$dst_path 
fi

if [$env =="sit"]       # System Integrety and Testing
then
  scp $src_path $username@$ip:$dst_path
fi

if [$env =="uat"]   # UAT (User Acceptance Testing)
then
  scp $src_path $username@$ip:$dst_path
fi

if [$env =="prod"]
then
  scp $scr_path $username@$ip:$dst_path
fi

# OR CASE STATmENT
cuase $env in 
dev) scp $scr_path $username@$ip:$dst_path
;;
sit) scp $scr_path $username@$ip:$dst_path
;;
uat) scp $scr_path $username@$ip:$dst_path
;;
prod) scp $scr_path $username@$ip:$dst_path
;;
*) echo"incorrect parameter plz check and correct it"
;;

#+END_SRC
*** Example run remote script 
https://www.linuxtechi.com/scp-command-examples-in-linux/
#+BEGIN_SRC sh
ssh devops@3.15.169.84
#Enter password
exit

scp tuesday devops@3.15.169.84 :/opt 
# If permission is denied (make sure devops user has root privilage)
# or sudo chmod 777 /opt/tuesday
cat delete.sh

touch sbi.war
scp sbi.war devops@3.15.169.84:/opt


#!/bash/bash

delete(){
rm -rf /opt/test*
}
delete
# run scripts from master on slave
ssh devops@3.15.169.84 sh /opt/delete.sh
#+END_SRC

*** AWS-EC2
#+BEGIN_SRC sh
scp -i key.pem /path/to/myfile.txt ec2-user@IPAddressOfEC2:/ 
#+END_SRC
** bel
#+BEGIN_SRC sh
( speaker-test -t sine -f 1000 )& pid=$! ; sleep 1s ; kill -9 $pid
#+END_SRC
* Vagrant
** Vagrant Virtualization (Creating virtual meachine Environment)
*** Introduction Why Virtualization 
**** Why use the Virtualization (Linux installallation) in class ?
- No suprises which lets you to stay  focused on scripting
- Allow you to get the best help possible(in class all students has same os)
- Quickly crete multiple Linux system
**** What is Virtualization Software 
- Allow to RUN Linux inside virtual machine(eg: VirtualBox(oracle) )
- Free to download and easy to install
- Run on winodws,mac,linux 
- Provides full virtualization are know as Virtual Box(). 
- Pyhsical computer = host.
- Virtual Computer = guest
- Guest OS think it's runing on real hardware but it is actually running on host Os
**** Why Vagrant
- In VirtualBox we can manually create a virtual os, but it is difficult to replicate the os(type, config,share sys setting) to other computers. So Vagrant provieds it
- Virtual Box is time consuming , not automate it
- Easy to configure , reproduce environments
***** Pros and Cons of Vagrant
- Pros
  - Free
  - Automation of virtual machine management tasks
  - Easy to use commands
  - Easy to Configure of OS, Share Configuration of Os  
  - Local testing
  - Well Documented
  - Vagrant is decentralized so anyone can make a container package to get a project started. you aren't limited to wordpress, or even one style of wordpress install (you can make a sage.io wordpress environment).
  - Vagrant easily lets you set ports and URLs for local development.
- Cons
  - Can be difficult to set up(setup in cmd ) Lacks a GUI
  - Uses lots of resources on old machines
  - Compatibility issues with some operating systems (Windows 8.1 home, Windows 10 home)
  - Can take up a lot of disk space if running several VMs with various configurations



    


**** Vagrant Boxes 
Box = Operating System Image
#+BEGIN_SRC sh
# vargrant box add <USER>/<BOX> # USER : user name of os, BOX : Iso image of OS
# Eg:
vargrant box add jasonc/centos7
#+END_SRC
**** Create Vagrant Projects
To Create a Vagrant Project :
- Create and Open a Folder
- Inicialize Vagrant Project
#+BEGIN_SRC sh
mkdir VagrantProject1
cd VagrantProject1
vagrant init jasonc/centos7 
vagrant up
#+END_SRC

**** Start Virtual machine in Vagrant Project 
#+BEGIN_SRC sh
vagrant up # Vagrant will import box into Virtual Box and start it.

#+END_SRC
**** Vagrant Up/ multi-machine
#+BEGIN_SRC sh
#Synatx:
#       vagrant up <Vm_Name>
vagrant up master
vagrant up server1
vagrant up          # start all virtual machines 
#+END_SRC
*** SSH-Secure Shell
**** Introduction
SSH : Secure Shell
Cryptographic Network Protocol
Uses for acessing remote servers
SSH uses Asysmmetric Cipers
In cryptograph,cipher is an algorithm for performing encryption and decryption
- Why we need ssh
  - Username and password can be stolen in middle but ssh ensure no 3rd party know username and password

- SSH create public key and a private pair
  - private key is not share to any one
  - public key is shared to any one

- There are many encryption methods like (rsa, dsa, ed25519...etc)

Cons in SSH:
 - Since it's a service, so its not available until system starts
 - If by mistake (forgot or deleted private key)  then you can't log back in
https://www.youtube.com/watch?v=y2SWzw9D4RA 
 https://www.youtube.com/watch?v=AtuAdk4MwWw : Dynamic ssh, reverser ssh, ssh tunneling

Network protacol used to connect to Linux
No built-in SSH client
Git include as SSH client
**** SSH in Vagrant
Vagrant provide simple shortcut to ssh into the meachine
#+BEGIN_SRC sh
vagrant ssh <Vm-name> # Vm-name :to ssh into Project name
exit # to end ssh connection
# log out of the Linux system by running the "exit" command.
#+END_SRC

**** Vagrant Halt,Suspent,Resume,Destroy
Vagrant it can use to control the Vm   like halt
#+BEGIN_SRC sh
vagrant halt <vm-name> # halt <vm-name>
vagrant halt           # halt all virtual machines 
# you will not lose any work you’ve performed on the virtual machine.  The virtual machine will still exist in VirtualBox, it will simply be stopped.
vagrant up <vm-name> # start and
vagrant suspend <vm-name>  # to suspend
vagrant resume <vm-name>   # to resume 
vagrant destroy <vm-name>  # to remove virtual-meachine from virtual box
# you want to start over with a fresh copy of the virtual machine, run "vagrant destroy" all work inside virtual-meachine will be lost.
vagrant # help
#+END_SRC 
**** Vagrantfile[in Project file]

#+BEGIN_SRC sh
Vagrant.configure(2) do |config|
   config.vm.box = "jasonc/centos7"  #Operating System like Ubuntu-64, Centos,...etc
   config.vm.network "private_network", ip "10.2.3.4" # How your host see your box : configure ip address...etc
   config.vm.provision "shell",path ="setup.sh" # what we want setup # lamp stack, mean stack,Nodejs
   config.vm.synced_folder # How you access file in your computer : edit files using atom, vs code.....etc
   config.vm.provider # Virtualbox like hyperV, VmWare
end
#+END_SRC

**** Example fo vagrant file
#+BEGIN_SRC sh
    Vagrant.configure("2") do |config|
      config.vm.box = "jasonc/centos7"
      config.vm.define "test1" do |test1|
        test1.vm.hostname = "test1"
        test1.vm.network "private_network", ip: "10.9.8.5"
      end
      config.vm.define "test2" do |test2|
        test2.vm.hostname = "test2"
        test2.vm.network "private_network", ip: "10.9.8.6"
      end
    end

#+END_SRC
#+BEGIN_SRC sh 
config.vm.box = "ubuntu/trusty64"
# config.vm.box = "jasonc/centos7"
config.vm.provider "virtualbox" do |vb|
#+END_SRC
**** Vagrantfile
#+BEGIN_SRC sh
# vi Vagrantfile
Vagrant.configure(2) do | config | 
     config.vm.box= "jasonc/centos7"
     config.vm.hostname = "linuxsvrl"
     config.vm.network "private_network", ip :"10.2.3.4"
     config.vm.provider "virtualbox" do |vb|
       vb.gui = true
       vb.memory = "1024"
     end    
     config.vm.provision "shell", path : "setup.sh"
end
#+END_SRC
*** Config vagrant file for multi-virtual machine project
#+BEGIN_SRC sh
vagrant box add jasonc/centos7   # img is load in os
cd /Workspace/Shell/shellclass
mkdir multitest
cd multitest
vagrant init jasonc/centos7
# edit vagrantfile 
vi vagrantfile                 # inside vagrantfiel
Vagrant.configure("2") do |config|
   config.vm.box = "jasonc/centos7"  

   config.vm.define "test1" do |test1|
       test1.vm.hostname = "test1"
       test1.vm.network "private_network", ip "10.9.8.5" # How your host see your
   end 

   config.vm.define "test2" do |test2|
       test1.vm.hostname = "test2"
       test1.vm.network "private_network", ip "10.9.8.6" # How your host see your
   end 
end


# in terminal in /Workspaec/Shell/shellcalss/multitest
vagrant up   # up every meachines test1,test2
vagrant status # show 2 running virtualbox
vagrant ssh test1
exit 
vagrant ssh test2
ping -c 3 10.9.8.6 # ip address of test2 system
#+END_SRC

*** Excersise 
#+BEGIN_SRC sh
cd /Workspace/Linux_script/udemy_shellclass/
cd localuser
# pwd Workspace/Linux_script/udemy_shellclass/
vagrant init jasonc/centos7
vagrant up
vagrant status
vagrant ssh
# root
# |- Vagrant  (home directory)
#    |- Vagrantfile(config)
#+END_SRC
** Creating User Account in Vagrant 
*** Introduction 
- Your First Script
 - Create new account 
 - Checks for proper privileges 
 - Reports if account creation failed
- But 1st need to Learn all *Concepts and Techinques*
 - project based learing helps you learn and retain new material
 - You'll use what you learn in the appropiate context
- Net 4 Lesson consist of demonstration and teaching
  - You can watch or follow along
  - All scripts are in course download
- Practice Your Skills in Exercise
 - Follow instruction for exercise
 - You'll write the script and test it.
 - Watch the instruction implement  script

*CONTINUE LECTURE*

*** Creating
#+BEGIN_SRC sh
# man useradd  
# useradd [options] LOGIN : Login are username , there should be 8 char or less it's general  practice, but it can more tha 8-char eg: ps -ef
# usernaem is case sensetive, No special chara

sudo useradd dougstamper   # create user : dougstamper
passwd # set passwd for  dougstamper


#+END_SRC
* Linux Interview Question
** 36) What are environmental variables?

Environmental variables are global settings that control the shell's function as well as that of other Linux programs. Another common term for environmental variables is global shell variables.

** 39) What is redirection?

Redirection is the process of directing data from one output to another. It can also be used to direct an output as an input to another process.

** 40) What is grep command?

grep a search command that makes use of pattern-based searching. It makes use of options and parameters that are specified along with the command line and applies this pattern in searching the required file output. 

** 43) How do you terminate an ongoing process?

Every process in the system is identified by a unique process id or pid. Use the kill command followed by the pid to terminate that process. To terminate all process at once, use kill 0. 
** 46) How do you execute more than one command or program from a single command line entry?

You can combine several commands by separating each command or program using a semicolon symbol. For example, you can issue such a series of commands in a single entry: 
** 47) Write a command that will look for files with an extension "c", and has the occurrence of the string "apple" in it.

Answer:

 Find ./ -name "*.c" | xargs grep –i "apple"

** 48) Write a command that will display all .txt files, including its individual permission.

Answer:

ls -al *.txt
** more questions
https://www.edureka.co/blog/interview-questions/linux-interview-questions-for-beginners/

** 28. What are the Process states in Linux?

Ans:  Five process states in Linux. They are

   -  New/ Ready: A new process is created and ready to run.
   -  Running: The process is being executed.
   -  Blocked/ Wait: The process is waiting for input from the user. 
   -  Terminated/ Completed: The process completed the execution or terminated by the operating system. 
   -  Zombie: The process is deleted, but still the information regarding the process exists in the process table.

Linux Process states
